# Go语言的特点
## 3-1为什么要用Go语言
### 与C/C++语言对比
1. C语言不是面向对象
2. 直接编译为机器吗，不需要执行环境
3. 一次编码只能适用一种平台
4. 自己处理GC问题  

### 与Java语言对比
1. 编译为字节码
2. 需要JVM执行环境
3. build onece，run everywhere
4. 有虚拟化损失 

### 与JS语言对比
1. 不需要编译，直接解释执行
2. 需要执行环境
3. 有虚拟化损失 

### Go语言特点
1. 直接编译为二进制，没有虚拟化损失
2. 自带运行环境，无需处理GC问题
3. 一次编码可以适用多种平台 
4. 超强的并发支持能力与并发易用性

### 优秀Go语言项目
docker、kubernetes、etcd、codis、BeeGo、falcon、bilibili、TiDB 

### 总结
1. Go综合了多种语言优势
2. Go是一种天生支持高性能并发的语言
3. Go在工业界有广泛的应用 

## 3-2何为Runtime？

### 很多语言都有Runtime
1. Runtime就是程序的运行环境
2. Java：Java虚拟机
3. JavaScript：浏览器内核  

### Go的Runtime特点
1. 没有虚拟机的概念
2. Runtime作为程序的一部分打包进二进制产物（Go+Runtime）
3. Runtime随用户程序一起运行
4. Runtime与用户程序没有明显界限，直接通过函数调用 

### Go的Runtime能力
1. 内存管理能力
2. 垃圾回收能力（GC）
3. 超强的并发能力（协程调度）

### Go的Runtime其他特点
1. Runtime有一定的屏蔽系统调用能力
2. 一些go的关键字其实是Runtime下的函数 

### 总结
1. Go的Runtime负责内存管理、垃圾回收、协程调度
2. Go的Runtime被编译为用户程序的一部分，一起运行

## 3-3Go程序是如何编译的？
go build -n:输出编译过程
### 词法分析
1. 将源代码翻译成Token
2. Token是代码中的最小语义结构

### 句法分析
1. Token序列经过处理，变成语法树

### 语义分析
1. 类型检查
2. 类型推断
3. 查看类型是否匹配
4. 函数调用内联
5. 逃逸分析（Go的变量是放到堆、还是栈，去选择分配）

### 中间码生成（SSA）
1. 为了处理不同平台的差异，先生成中间代码（SSA）
2. 查看从代码到SSA中间码的整个过程
* $env:GOSSAFUNC="main"
* export GOSSAFUNC=main

### 机器码生成
1. 先生成Plan9汇编代码
* go build -gcflags -S main.go
2. 最后编译为机器码
3. 输出的机器码为.a文件

### 链接
1. 将各个包进行链接，包括runtime（将.a文件生成exe文件）

### 总结
1. 编译前端
* 词法分析
* 句法分析
* 语义分析
2. 编译后端
* 中间码生成
* 代码优化
* 机器码生成
3. 链接

## 3-4Go程序是如何运行的？
### Go程序的入口？
* main方法？
* runtime/rt0_XXX.s(汇编文件)
* 读取命令行参数
1. 复制参数数量argc和参数值argv到栈上
* 初始化g0执行栈
1. g0是为了调度协程而产生的协程
2. g0是每个Go程序的第一个协程
* 运行时检测
1. 检查各种类型长度
2. 检查指针操作
3. 检查结构体字段的偏移量
4. 检查atomic原子操作
5. 检查CAS操作
6. 检查栈大小是否是2的幂次
* 参数初始化 runtime.args
1. 对命令行中的参数进行处理
2. 参数数量赋值给argc int32
3. 参数值赋值给argv **byte
* 调度器初始化runtime.schedinit
1. 全局栈空间内存分配
2. 加载命令行参数到os.Args
3. 堆内存空间初始化
4. 加载操作系统环境变量
5. 初始化当前系统线程
6. 垃圾回收器的参数初始化
7. 算法初始化（map、hash）
8. 设置process数量
* 创建主协程
1. 创建一个新协程，执行runtime.main
2. 放入调度器等待调度
* 初始化M
1. 初始化一个M，用来调度主协程
* 主协程执行主函数
1. 

## Go是面向对象的吗？
Yes and no 